// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_webhook

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func WebhookResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"webhook": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authentication": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"add_position": schema.StringAttribute{
								Optional: true,
							},
							"data": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"password": schema.StringAttribute{
										Optional:  true,
										Sensitive: true,
									},
									"token": schema.StringAttribute{
										Optional:  true,
										Sensitive: true,
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: DataType{
									ObjectType: types.ObjectType{
										AttrTypes: DataValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"type": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: AuthenticationType{
							ObjectType: types.ObjectType{
								AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"created_at": schema.StringAttribute{
						Computed: true,
					},
					"created_by": schema.StringAttribute{
						Computed: true,
					},
					"custom_headers": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"description": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"endpoint": schema.StringAttribute{
						Required: true,
					},
					"external_source": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"external_source_data": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"app_id": schema.StringAttribute{
										Optional: true,
										Computed: true,
									},
									"installation_id": schema.StringAttribute{
										Optional: true,
										Computed: true,
									},
								},
								CustomType: ExternalSourceDataType{
									ObjectType: types.ObjectType{
										AttrTypes: ExternalSourceDataValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
								Computed: true,
							},
							"type": schema.StringAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: ExternalSourceType{
							ObjectType: types.ObjectType{
								AttrTypes: ExternalSourceValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"http_method": schema.StringAttribute{
						Required: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Required: true,
					},
					"request_format": schema.StringAttribute{
						Required: true,
					},
					"signing_secret": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"algorithm": schema.StringAttribute{
								Computed: true,
							},
							"secret": schema.StringAttribute{
								Computed:  true,
								Sensitive: true,
							},
						},
						CustomType: SigningSecretType{
							ObjectType: types.ObjectType{
								AttrTypes: SigningSecretValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"status": schema.StringAttribute{
						Required: true,
					},
					"subscriptions": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"updated_at": schema.StringAttribute{
						Computed: true,
					},
					"updated_by": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: WebhookType{
					ObjectType: types.ObjectType{
						AttrTypes: WebhookValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"webhook_id": schema.StringAttribute{
				Computed:            true,
				Description:         "(Required) Webhook id",
				MarkdownDescription: "(Required) Webhook id",
			},
		},
	}
}

type WebhookModel struct {
	Webhook   WebhookValue `tfsdk:"webhook"`
	WebhookId types.String `tfsdk:"webhook_id"`
}

var _ basetypes.ObjectTypable = WebhookType{}

type WebhookType struct {
	basetypes.ObjectType
}

func (t WebhookType) Equal(o attr.Type) bool {
	other, ok := o.(WebhookType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WebhookType) String() string {
	return "WebhookType"
}

func (t WebhookType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authenticationAttribute, ok := attributes["authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication is missing from object`)

		return nil, diags
	}

	authenticationVal, ok := authenticationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication expected to be basetypes.ObjectValue, was: %T`, authenticationAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	createdByAttribute, ok := attributes["created_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_by is missing from object`)

		return nil, diags
	}

	createdByVal, ok := createdByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_by expected to be basetypes.StringValue, was: %T`, createdByAttribute))
	}

	customHeadersAttribute, ok := attributes["custom_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_headers is missing from object`)

		return nil, diags
	}

	customHeadersVal, ok := customHeadersAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_headers expected to be basetypes.MapValue, was: %T`, customHeadersAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	endpointAttribute, ok := attributes["endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint is missing from object`)

		return nil, diags
	}

	endpointVal, ok := endpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint expected to be basetypes.StringValue, was: %T`, endpointAttribute))
	}

	externalSourceAttribute, ok := attributes["external_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_source is missing from object`)

		return nil, diags
	}

	externalSourceVal, ok := externalSourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_source expected to be basetypes.ObjectValue, was: %T`, externalSourceAttribute))
	}

	httpMethodAttribute, ok := attributes["http_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_method is missing from object`)

		return nil, diags
	}

	httpMethodVal, ok := httpMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_method expected to be basetypes.StringValue, was: %T`, httpMethodAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requestFormatAttribute, ok := attributes["request_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_format is missing from object`)

		return nil, diags
	}

	requestFormatVal, ok := requestFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_format expected to be basetypes.StringValue, was: %T`, requestFormatAttribute))
	}

	signingSecretAttribute, ok := attributes["signing_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`signing_secret is missing from object`)

		return nil, diags
	}

	signingSecretVal, ok := signingSecretAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`signing_secret expected to be basetypes.ObjectValue, was: %T`, signingSecretAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subscriptionsAttribute, ok := attributes["subscriptions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscriptions is missing from object`)

		return nil, diags
	}

	subscriptionsVal, ok := subscriptionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscriptions expected to be basetypes.ListValue, was: %T`, subscriptionsAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	updatedByAttribute, ok := attributes["updated_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_by is missing from object`)

		return nil, diags
	}

	updatedByVal, ok := updatedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_by expected to be basetypes.StringValue, was: %T`, updatedByAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WebhookValue{
		Authentication: authenticationVal,
		CreatedAt:      createdAtVal,
		CreatedBy:      createdByVal,
		CustomHeaders:  customHeadersVal,
		Description:    descriptionVal,
		Endpoint:       endpointVal,
		ExternalSource: externalSourceVal,
		HttpMethod:     httpMethodVal,
		Id:             idVal,
		Name:           nameVal,
		RequestFormat:  requestFormatVal,
		SigningSecret:  signingSecretVal,
		Status:         statusVal,
		Subscriptions:  subscriptionsVal,
		UpdatedAt:      updatedAtVal,
		UpdatedBy:      updatedByVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewWebhookValueNull() WebhookValue {
	return WebhookValue{
		state: attr.ValueStateNull,
	}
}

func NewWebhookValueUnknown() WebhookValue {
	return WebhookValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWebhookValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WebhookValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WebhookValue Attribute Value",
				"While creating a WebhookValue value, a missing attribute value was detected. "+
					"A WebhookValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WebhookValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WebhookValue Attribute Type",
				"While creating a WebhookValue value, an invalid attribute value was detected. "+
					"A WebhookValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WebhookValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WebhookValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WebhookValue Attribute Value",
				"While creating a WebhookValue value, an extra attribute value was detected. "+
					"A WebhookValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WebhookValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWebhookValueUnknown(), diags
	}

	authenticationAttribute, ok := attributes["authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	authenticationVal, ok := authenticationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication expected to be basetypes.ObjectValue, was: %T`, authenticationAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	createdByAttribute, ok := attributes["created_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_by is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	createdByVal, ok := createdByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_by expected to be basetypes.StringValue, was: %T`, createdByAttribute))
	}

	customHeadersAttribute, ok := attributes["custom_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_headers is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	customHeadersVal, ok := customHeadersAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_headers expected to be basetypes.MapValue, was: %T`, customHeadersAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	endpointAttribute, ok := attributes["endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	endpointVal, ok := endpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint expected to be basetypes.StringValue, was: %T`, endpointAttribute))
	}

	externalSourceAttribute, ok := attributes["external_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_source is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	externalSourceVal, ok := externalSourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_source expected to be basetypes.ObjectValue, was: %T`, externalSourceAttribute))
	}

	httpMethodAttribute, ok := attributes["http_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_method is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	httpMethodVal, ok := httpMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_method expected to be basetypes.StringValue, was: %T`, httpMethodAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requestFormatAttribute, ok := attributes["request_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_format is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	requestFormatVal, ok := requestFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_format expected to be basetypes.StringValue, was: %T`, requestFormatAttribute))
	}

	signingSecretAttribute, ok := attributes["signing_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`signing_secret is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	signingSecretVal, ok := signingSecretAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`signing_secret expected to be basetypes.ObjectValue, was: %T`, signingSecretAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subscriptionsAttribute, ok := attributes["subscriptions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscriptions is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	subscriptionsVal, ok := subscriptionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscriptions expected to be basetypes.ListValue, was: %T`, subscriptionsAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	updatedByAttribute, ok := attributes["updated_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_by is missing from object`)

		return NewWebhookValueUnknown(), diags
	}

	updatedByVal, ok := updatedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_by expected to be basetypes.StringValue, was: %T`, updatedByAttribute))
	}

	if diags.HasError() {
		return NewWebhookValueUnknown(), diags
	}

	return WebhookValue{
		Authentication: authenticationVal,
		CreatedAt:      createdAtVal,
		CreatedBy:      createdByVal,
		CustomHeaders:  customHeadersVal,
		Description:    descriptionVal,
		Endpoint:       endpointVal,
		ExternalSource: externalSourceVal,
		HttpMethod:     httpMethodVal,
		Id:             idVal,
		Name:           nameVal,
		RequestFormat:  requestFormatVal,
		SigningSecret:  signingSecretVal,
		Status:         statusVal,
		Subscriptions:  subscriptionsVal,
		UpdatedAt:      updatedAtVal,
		UpdatedBy:      updatedByVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewWebhookValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WebhookValue {
	object, diags := NewWebhookValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWebhookValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WebhookType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWebhookValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWebhookValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWebhookValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWebhookValueMust(WebhookValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WebhookType) ValueType(ctx context.Context) attr.Value {
	return WebhookValue{}
}

var _ basetypes.ObjectValuable = WebhookValue{}

type WebhookValue struct {
	Authentication basetypes.ObjectValue `tfsdk:"authentication"`
	CreatedAt      basetypes.StringValue `tfsdk:"created_at"`
	CreatedBy      basetypes.StringValue `tfsdk:"created_by"`
	CustomHeaders  basetypes.MapValue    `tfsdk:"custom_headers"`
	Description    basetypes.StringValue `tfsdk:"description"`
	Endpoint       basetypes.StringValue `tfsdk:"endpoint"`
	ExternalSource basetypes.ObjectValue `tfsdk:"external_source"`
	HttpMethod     basetypes.StringValue `tfsdk:"http_method"`
	Id             basetypes.StringValue `tfsdk:"id"`
	Name           basetypes.StringValue `tfsdk:"name"`
	RequestFormat  basetypes.StringValue `tfsdk:"request_format"`
	SigningSecret  basetypes.ObjectValue `tfsdk:"signing_secret"`
	Status         basetypes.StringValue `tfsdk:"status"`
	Subscriptions  basetypes.ListValue   `tfsdk:"subscriptions"`
	UpdatedAt      basetypes.StringValue `tfsdk:"updated_at"`
	UpdatedBy      basetypes.StringValue `tfsdk:"updated_by"`
	state          attr.ValueState
}

func (v WebhookValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["authentication"] = basetypes.ObjectType{
		AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_headers"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["endpoint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_source"] = basetypes.ObjectType{
		AttrTypes: ExternalSourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["http_method"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["request_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["signing_secret"] = basetypes.ObjectType{
		AttrTypes: SigningSecretValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subscriptions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_by"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Authentication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CreatedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_by"] = val

		val, err = v.CustomHeaders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_headers"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Endpoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint"] = val

		val, err = v.ExternalSource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_source"] = val

		val, err = v.HttpMethod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_method"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.RequestFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_format"] = val

		val, err = v.SigningSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["signing_secret"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Subscriptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subscriptions"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.UpdatedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_by"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WebhookValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WebhookValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WebhookValue) String() string {
	return "WebhookValue"
}

func (v WebhookValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var authentication basetypes.ObjectValue

	if v.Authentication.IsNull() {
		authentication = types.ObjectNull(
			AuthenticationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Authentication.IsUnknown() {
		authentication = types.ObjectUnknown(
			AuthenticationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Authentication.IsNull() && !v.Authentication.IsUnknown() {
		authentication = types.ObjectValueMust(
			AuthenticationValue{}.AttributeTypes(ctx),
			v.Authentication.Attributes(),
		)
	}

	var externalSource basetypes.ObjectValue

	if v.ExternalSource.IsNull() {
		externalSource = types.ObjectNull(
			ExternalSourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.ExternalSource.IsUnknown() {
		externalSource = types.ObjectUnknown(
			ExternalSourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ExternalSource.IsNull() && !v.ExternalSource.IsUnknown() {
		externalSource = types.ObjectValueMust(
			ExternalSourceValue{}.AttributeTypes(ctx),
			v.ExternalSource.Attributes(),
		)
	}

	var signingSecret basetypes.ObjectValue

	if v.SigningSecret.IsNull() {
		signingSecret = types.ObjectNull(
			SigningSecretValue{}.AttributeTypes(ctx),
		)
	}

	if v.SigningSecret.IsUnknown() {
		signingSecret = types.ObjectUnknown(
			SigningSecretValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SigningSecret.IsNull() && !v.SigningSecret.IsUnknown() {
		signingSecret = types.ObjectValueMust(
			SigningSecretValue{}.AttributeTypes(ctx),
			v.SigningSecret.Attributes(),
		)
	}

	customHeadersVal, d := types.MapValue(types.StringType, v.CustomHeaders.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"authentication": basetypes.ObjectType{
				AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
			},
			"created_at": basetypes.StringType{},
			"created_by": basetypes.StringType{},
			"custom_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"endpoint":    basetypes.StringType{},
			"external_source": basetypes.ObjectType{
				AttrTypes: ExternalSourceValue{}.AttributeTypes(ctx),
			},
			"http_method":    basetypes.StringType{},
			"id":             basetypes.StringType{},
			"name":           basetypes.StringType{},
			"request_format": basetypes.StringType{},
			"signing_secret": basetypes.ObjectType{
				AttrTypes: SigningSecretValue{}.AttributeTypes(ctx),
			},
			"status": basetypes.StringType{},
			"subscriptions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"updated_at": basetypes.StringType{},
			"updated_by": basetypes.StringType{},
		}), diags
	}

	subscriptionsVal, d := types.ListValue(types.StringType, v.Subscriptions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"authentication": basetypes.ObjectType{
				AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
			},
			"created_at": basetypes.StringType{},
			"created_by": basetypes.StringType{},
			"custom_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"endpoint":    basetypes.StringType{},
			"external_source": basetypes.ObjectType{
				AttrTypes: ExternalSourceValue{}.AttributeTypes(ctx),
			},
			"http_method":    basetypes.StringType{},
			"id":             basetypes.StringType{},
			"name":           basetypes.StringType{},
			"request_format": basetypes.StringType{},
			"signing_secret": basetypes.ObjectType{
				AttrTypes: SigningSecretValue{}.AttributeTypes(ctx),
			},
			"status": basetypes.StringType{},
			"subscriptions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"updated_at": basetypes.StringType{},
			"updated_by": basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"authentication": basetypes.ObjectType{
				AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
			},
			"created_at": basetypes.StringType{},
			"created_by": basetypes.StringType{},
			"custom_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"endpoint":    basetypes.StringType{},
			"external_source": basetypes.ObjectType{
				AttrTypes: ExternalSourceValue{}.AttributeTypes(ctx),
			},
			"http_method":    basetypes.StringType{},
			"id":             basetypes.StringType{},
			"name":           basetypes.StringType{},
			"request_format": basetypes.StringType{},
			"signing_secret": basetypes.ObjectType{
				AttrTypes: SigningSecretValue{}.AttributeTypes(ctx),
			},
			"status": basetypes.StringType{},
			"subscriptions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"updated_at": basetypes.StringType{},
			"updated_by": basetypes.StringType{},
		},
		map[string]attr.Value{
			"authentication":  authentication,
			"created_at":      v.CreatedAt,
			"created_by":      v.CreatedBy,
			"custom_headers":  customHeadersVal,
			"description":     v.Description,
			"endpoint":        v.Endpoint,
			"external_source": externalSource,
			"http_method":     v.HttpMethod,
			"id":              v.Id,
			"name":            v.Name,
			"request_format":  v.RequestFormat,
			"signing_secret":  signingSecret,
			"status":          v.Status,
			"subscriptions":   subscriptionsVal,
			"updated_at":      v.UpdatedAt,
			"updated_by":      v.UpdatedBy,
		})

	return objVal, diags
}

func (v WebhookValue) Equal(o attr.Value) bool {
	other, ok := o.(WebhookValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Authentication.Equal(other.Authentication) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CreatedBy.Equal(other.CreatedBy) {
		return false
	}

	if !v.CustomHeaders.Equal(other.CustomHeaders) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Endpoint.Equal(other.Endpoint) {
		return false
	}

	if !v.ExternalSource.Equal(other.ExternalSource) {
		return false
	}

	if !v.HttpMethod.Equal(other.HttpMethod) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.RequestFormat.Equal(other.RequestFormat) {
		return false
	}

	if !v.SigningSecret.Equal(other.SigningSecret) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Subscriptions.Equal(other.Subscriptions) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.UpdatedBy.Equal(other.UpdatedBy) {
		return false
	}

	return true
}

func (v WebhookValue) Type(ctx context.Context) attr.Type {
	return WebhookType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WebhookValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authentication": basetypes.ObjectType{
			AttrTypes: AuthenticationValue{}.AttributeTypes(ctx),
		},
		"created_at": basetypes.StringType{},
		"created_by": basetypes.StringType{},
		"custom_headers": basetypes.MapType{
			ElemType: types.StringType,
		},
		"description": basetypes.StringType{},
		"endpoint":    basetypes.StringType{},
		"external_source": basetypes.ObjectType{
			AttrTypes: ExternalSourceValue{}.AttributeTypes(ctx),
		},
		"http_method":    basetypes.StringType{},
		"id":             basetypes.StringType{},
		"name":           basetypes.StringType{},
		"request_format": basetypes.StringType{},
		"signing_secret": basetypes.ObjectType{
			AttrTypes: SigningSecretValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.StringType{},
		"subscriptions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"updated_at": basetypes.StringType{},
		"updated_by": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthenticationType{}

type AuthenticationType struct {
	basetypes.ObjectType
}

func (t AuthenticationType) Equal(o attr.Type) bool {
	other, ok := o.(AuthenticationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthenticationType) String() string {
	return "AuthenticationType"
}

func (t AuthenticationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addPositionAttribute, ok := attributes["add_position"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_position is missing from object`)

		return nil, diags
	}

	addPositionVal, ok := addPositionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_position expected to be basetypes.StringValue, was: %T`, addPositionAttribute))
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthenticationValue{
		AddPosition:        addPositionVal,
		Data:               dataVal,
		AuthenticationType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAuthenticationValueNull() AuthenticationValue {
	return AuthenticationValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthenticationValueUnknown() AuthenticationValue {
	return AuthenticationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthenticationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthenticationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthenticationValue Attribute Value",
				"While creating a AuthenticationValue value, a missing attribute value was detected. "+
					"A AuthenticationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthenticationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthenticationValue Attribute Type",
				"While creating a AuthenticationValue value, an invalid attribute value was detected. "+
					"A AuthenticationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthenticationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthenticationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthenticationValue Attribute Value",
				"While creating a AuthenticationValue value, an extra attribute value was detected. "+
					"A AuthenticationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthenticationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthenticationValueUnknown(), diags
	}

	addPositionAttribute, ok := attributes["add_position"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_position is missing from object`)

		return NewAuthenticationValueUnknown(), diags
	}

	addPositionVal, ok := addPositionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_position expected to be basetypes.StringValue, was: %T`, addPositionAttribute))
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewAuthenticationValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthenticationValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAuthenticationValueUnknown(), diags
	}

	return AuthenticationValue{
		AddPosition:        addPositionVal,
		Data:               dataVal,
		AuthenticationType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAuthenticationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthenticationValue {
	object, diags := NewAuthenticationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthenticationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthenticationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthenticationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthenticationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthenticationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthenticationValueMust(AuthenticationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthenticationType) ValueType(ctx context.Context) attr.Value {
	return AuthenticationValue{}
}

var _ basetypes.ObjectValuable = AuthenticationValue{}

type AuthenticationValue struct {
	AddPosition        basetypes.StringValue `tfsdk:"add_position"`
	Data               basetypes.ObjectValue `tfsdk:"data"`
	AuthenticationType basetypes.StringValue `tfsdk:"type"`
	state              attr.ValueState
}

func (v AuthenticationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["add_position"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["data"] = basetypes.ObjectType{
		AttrTypes: DataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AddPosition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_position"] = val

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		val, err = v.AuthenticationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthenticationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthenticationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthenticationValue) String() string {
	return "AuthenticationValue"
}

func (v AuthenticationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var data basetypes.ObjectValue

	if v.Data.IsNull() {
		data = types.ObjectNull(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Data.IsUnknown() {
		data = types.ObjectUnknown(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Data.IsNull() && !v.Data.IsUnknown() {
		data = types.ObjectValueMust(
			DataValue{}.AttributeTypes(ctx),
			v.Data.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"add_position": basetypes.StringType{},
			"data": basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
			"type": basetypes.StringType{},
		},
		map[string]attr.Value{
			"add_position": v.AddPosition,
			"data":         data,
			"type":         v.AuthenticationType,
		})

	return objVal, diags
}

func (v AuthenticationValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthenticationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddPosition.Equal(other.AddPosition) {
		return false
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	if !v.AuthenticationType.Equal(other.AuthenticationType) {
		return false
	}

	return true
}

func (v AuthenticationValue) Type(ctx context.Context) attr.Type {
	return AuthenticationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthenticationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add_position": basetypes.StringType{},
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Password: passwordVal,
		Token:    tokenVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewDataValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewDataValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewDataValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Password: passwordVal,
		Token:    tokenVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Password basetypes.StringValue `tfsdk:"password"`
	Token    basetypes.StringValue `tfsdk:"token"`
	Username basetypes.StringValue `tfsdk:"username"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"password": basetypes.StringType{},
			"token":    basetypes.StringType{},
			"username": basetypes.StringType{},
		},
		map[string]attr.Value{
			"password": v.Password,
			"token":    v.Token,
			"username": v.Username,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"password": basetypes.StringType{},
		"token":    basetypes.StringType{},
		"username": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExternalSourceType{}

type ExternalSourceType struct {
	basetypes.ObjectType
}

func (t ExternalSourceType) Equal(o attr.Type) bool {
	other, ok := o.(ExternalSourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExternalSourceType) String() string {
	return "ExternalSourceType"
}

func (t ExternalSourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	externalSourceDataAttribute, ok := attributes["external_source_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_source_data is missing from object`)

		return nil, diags
	}

	externalSourceDataVal, ok := externalSourceDataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_source_data expected to be basetypes.ObjectValue, was: %T`, externalSourceDataAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExternalSourceValue{
		ExternalSourceData: externalSourceDataVal,
		ExternalSourceType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewExternalSourceValueNull() ExternalSourceValue {
	return ExternalSourceValue{
		state: attr.ValueStateNull,
	}
}

func NewExternalSourceValueUnknown() ExternalSourceValue {
	return ExternalSourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExternalSourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExternalSourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExternalSourceValue Attribute Value",
				"While creating a ExternalSourceValue value, a missing attribute value was detected. "+
					"A ExternalSourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalSourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExternalSourceValue Attribute Type",
				"While creating a ExternalSourceValue value, an invalid attribute value was detected. "+
					"A ExternalSourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalSourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExternalSourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExternalSourceValue Attribute Value",
				"While creating a ExternalSourceValue value, an extra attribute value was detected. "+
					"A ExternalSourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExternalSourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExternalSourceValueUnknown(), diags
	}

	externalSourceDataAttribute, ok := attributes["external_source_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_source_data is missing from object`)

		return NewExternalSourceValueUnknown(), diags
	}

	externalSourceDataVal, ok := externalSourceDataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_source_data expected to be basetypes.ObjectValue, was: %T`, externalSourceDataAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewExternalSourceValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewExternalSourceValueUnknown(), diags
	}

	return ExternalSourceValue{
		ExternalSourceData: externalSourceDataVal,
		ExternalSourceType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewExternalSourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExternalSourceValue {
	object, diags := NewExternalSourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExternalSourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExternalSourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExternalSourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExternalSourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExternalSourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExternalSourceValueMust(ExternalSourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExternalSourceType) ValueType(ctx context.Context) attr.Value {
	return ExternalSourceValue{}
}

var _ basetypes.ObjectValuable = ExternalSourceValue{}

type ExternalSourceValue struct {
	ExternalSourceData basetypes.ObjectValue `tfsdk:"external_source_data"`
	ExternalSourceType basetypes.StringValue `tfsdk:"type"`
	state              attr.ValueState
}

func (v ExternalSourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["external_source_data"] = basetypes.ObjectType{
		AttrTypes: ExternalSourceDataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExternalSourceData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_source_data"] = val

		val, err = v.ExternalSourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExternalSourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExternalSourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExternalSourceValue) String() string {
	return "ExternalSourceValue"
}

func (v ExternalSourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var externalSourceData basetypes.ObjectValue

	if v.ExternalSourceData.IsNull() {
		externalSourceData = types.ObjectNull(
			ExternalSourceDataValue{}.AttributeTypes(ctx),
		)
	}

	if v.ExternalSourceData.IsUnknown() {
		externalSourceData = types.ObjectUnknown(
			ExternalSourceDataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ExternalSourceData.IsNull() && !v.ExternalSourceData.IsUnknown() {
		externalSourceData = types.ObjectValueMust(
			ExternalSourceDataValue{}.AttributeTypes(ctx),
			v.ExternalSourceData.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"external_source_data": basetypes.ObjectType{
				AttrTypes: ExternalSourceDataValue{}.AttributeTypes(ctx),
			},
			"type": basetypes.StringType{},
		},
		map[string]attr.Value{
			"external_source_data": externalSourceData,
			"type":                 v.ExternalSourceType,
		})

	return objVal, diags
}

func (v ExternalSourceValue) Equal(o attr.Value) bool {
	other, ok := o.(ExternalSourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExternalSourceData.Equal(other.ExternalSourceData) {
		return false
	}

	if !v.ExternalSourceType.Equal(other.ExternalSourceType) {
		return false
	}

	return true
}

func (v ExternalSourceValue) Type(ctx context.Context) attr.Type {
	return ExternalSourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExternalSourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"external_source_data": basetypes.ObjectType{
			AttrTypes: ExternalSourceDataValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExternalSourceDataType{}

type ExternalSourceDataType struct {
	basetypes.ObjectType
}

func (t ExternalSourceDataType) Equal(o attr.Type) bool {
	other, ok := o.(ExternalSourceDataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExternalSourceDataType) String() string {
	return "ExternalSourceDataType"
}

func (t ExternalSourceDataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return nil, diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	installationIdAttribute, ok := attributes["installation_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installation_id is missing from object`)

		return nil, diags
	}

	installationIdVal, ok := installationIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installation_id expected to be basetypes.StringValue, was: %T`, installationIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExternalSourceDataValue{
		AppId:          appIdVal,
		InstallationId: installationIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewExternalSourceDataValueNull() ExternalSourceDataValue {
	return ExternalSourceDataValue{
		state: attr.ValueStateNull,
	}
}

func NewExternalSourceDataValueUnknown() ExternalSourceDataValue {
	return ExternalSourceDataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExternalSourceDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExternalSourceDataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExternalSourceDataValue Attribute Value",
				"While creating a ExternalSourceDataValue value, a missing attribute value was detected. "+
					"A ExternalSourceDataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalSourceDataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExternalSourceDataValue Attribute Type",
				"While creating a ExternalSourceDataValue value, an invalid attribute value was detected. "+
					"A ExternalSourceDataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalSourceDataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExternalSourceDataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExternalSourceDataValue Attribute Value",
				"While creating a ExternalSourceDataValue value, an extra attribute value was detected. "+
					"A ExternalSourceDataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExternalSourceDataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExternalSourceDataValueUnknown(), diags
	}

	appIdAttribute, ok := attributes["app_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_id is missing from object`)

		return NewExternalSourceDataValueUnknown(), diags
	}

	appIdVal, ok := appIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_id expected to be basetypes.StringValue, was: %T`, appIdAttribute))
	}

	installationIdAttribute, ok := attributes["installation_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installation_id is missing from object`)

		return NewExternalSourceDataValueUnknown(), diags
	}

	installationIdVal, ok := installationIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installation_id expected to be basetypes.StringValue, was: %T`, installationIdAttribute))
	}

	if diags.HasError() {
		return NewExternalSourceDataValueUnknown(), diags
	}

	return ExternalSourceDataValue{
		AppId:          appIdVal,
		InstallationId: installationIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewExternalSourceDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExternalSourceDataValue {
	object, diags := NewExternalSourceDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExternalSourceDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExternalSourceDataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExternalSourceDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExternalSourceDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExternalSourceDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExternalSourceDataValueMust(ExternalSourceDataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExternalSourceDataType) ValueType(ctx context.Context) attr.Value {
	return ExternalSourceDataValue{}
}

var _ basetypes.ObjectValuable = ExternalSourceDataValue{}

type ExternalSourceDataValue struct {
	AppId          basetypes.StringValue `tfsdk:"app_id"`
	InstallationId basetypes.StringValue `tfsdk:"installation_id"`
	state          attr.ValueState
}

func (v ExternalSourceDataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["app_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["installation_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AppId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_id"] = val

		val, err = v.InstallationId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["installation_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExternalSourceDataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExternalSourceDataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExternalSourceDataValue) String() string {
	return "ExternalSourceDataValue"
}

func (v ExternalSourceDataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"app_id":          basetypes.StringType{},
			"installation_id": basetypes.StringType{},
		},
		map[string]attr.Value{
			"app_id":          v.AppId,
			"installation_id": v.InstallationId,
		})

	return objVal, diags
}

func (v ExternalSourceDataValue) Equal(o attr.Value) bool {
	other, ok := o.(ExternalSourceDataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppId.Equal(other.AppId) {
		return false
	}

	if !v.InstallationId.Equal(other.InstallationId) {
		return false
	}

	return true
}

func (v ExternalSourceDataValue) Type(ctx context.Context) attr.Type {
	return ExternalSourceDataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExternalSourceDataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"app_id":          basetypes.StringType{},
		"installation_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SigningSecretType{}

type SigningSecretType struct {
	basetypes.ObjectType
}

func (t SigningSecretType) Equal(o attr.Type) bool {
	other, ok := o.(SigningSecretType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SigningSecretType) String() string {
	return "SigningSecretType"
}

func (t SigningSecretType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	algorithmAttribute, ok := attributes["algorithm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`algorithm is missing from object`)

		return nil, diags
	}

	algorithmVal, ok := algorithmAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`algorithm expected to be basetypes.StringValue, was: %T`, algorithmAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SigningSecretValue{
		Algorithm: algorithmVal,
		Secret:    secretVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSigningSecretValueNull() SigningSecretValue {
	return SigningSecretValue{
		state: attr.ValueStateNull,
	}
}

func NewSigningSecretValueUnknown() SigningSecretValue {
	return SigningSecretValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSigningSecretValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SigningSecretValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SigningSecretValue Attribute Value",
				"While creating a SigningSecretValue value, a missing attribute value was detected. "+
					"A SigningSecretValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SigningSecretValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SigningSecretValue Attribute Type",
				"While creating a SigningSecretValue value, an invalid attribute value was detected. "+
					"A SigningSecretValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SigningSecretValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SigningSecretValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SigningSecretValue Attribute Value",
				"While creating a SigningSecretValue value, an extra attribute value was detected. "+
					"A SigningSecretValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SigningSecretValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSigningSecretValueUnknown(), diags
	}

	algorithmAttribute, ok := attributes["algorithm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`algorithm is missing from object`)

		return NewSigningSecretValueUnknown(), diags
	}

	algorithmVal, ok := algorithmAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`algorithm expected to be basetypes.StringValue, was: %T`, algorithmAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewSigningSecretValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewSigningSecretValueUnknown(), diags
	}

	return SigningSecretValue{
		Algorithm: algorithmVal,
		Secret:    secretVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSigningSecretValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SigningSecretValue {
	object, diags := NewSigningSecretValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSigningSecretValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SigningSecretType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSigningSecretValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSigningSecretValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSigningSecretValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSigningSecretValueMust(SigningSecretValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SigningSecretType) ValueType(ctx context.Context) attr.Value {
	return SigningSecretValue{}
}

var _ basetypes.ObjectValuable = SigningSecretValue{}

type SigningSecretValue struct {
	Algorithm basetypes.StringValue `tfsdk:"algorithm"`
	Secret    basetypes.StringValue `tfsdk:"secret"`
	state     attr.ValueState
}

func (v SigningSecretValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["algorithm"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Algorithm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["algorithm"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SigningSecretValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SigningSecretValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SigningSecretValue) String() string {
	return "SigningSecretValue"
}

func (v SigningSecretValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"algorithm": basetypes.StringType{},
			"secret":    basetypes.StringType{},
		},
		map[string]attr.Value{
			"algorithm": v.Algorithm,
			"secret":    v.Secret,
		})

	return objVal, diags
}

func (v SigningSecretValue) Equal(o attr.Value) bool {
	other, ok := o.(SigningSecretValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Algorithm.Equal(other.Algorithm) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v SigningSecretValue) Type(ctx context.Context) attr.Type {
	return SigningSecretType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SigningSecretValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"algorithm": basetypes.StringType{},
		"secret":    basetypes.StringType{},
	}
}
